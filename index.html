<!DOCTYPE html>
<html lang="en">
	<head>
		<meta charset="UTF-8" />
		<meta name="viewport" content="width=device-width, initial-scale=1.0" />
		<title>Slitherlink</title>
		<style>
			html,
			body {
				margin: 0;
				padding: 0;
				background-color: black;
				text-align: center;
			}
		</style>
	</head>

	<body>
		<canvas></canvas>
		<script>
			(function slitherlinkApp() {
				/* Structure:
				1) Local Variables
				2) Initialisation
				3) Animation
				4) Function Declarations */

				// Local Variables //

				// Example puzzle
				const puzzle = [
					[1, , 3, 1, , , , 2, , , , 0, 1, , ,],
					[, , , , 3, , , 3, , 2, , , , , 3],
					[2, , 1, , 3, , , 3, , 0, , 3, 2, , 3],
					[0, , , , , , , , , 3, , , , , 2],
					[, 3, 2, , 3, , , 3, , , , 1, 0, ,],
					[, , , , , , , 0, , , , , , ,],
					[, , , , , , , 3, , , 0, , , 3],
					[3, 0, 3, , 3, 1, 2, , , , 3, , , 3],
					[, , , , , , , , 1, , 1, , , 3],
					[, , , , , , , , 0, , , , , ,],
					[3, 3, 3, , 2, 3, 3, , 1, , , 1, , , 1],
					[, , , , , , , , , , , 3, , , 0],
					[3, , , 3, , , , , , , , 3, , , 2],
					[3, , , 3, , , , , , , , , , ,],
					[3, , , 3, , , 3, , 2, 3, 3, , 3, 0, 2],
					[, , , , , , 1, , , , , , , ,],
					[, 2, , , 3, , 2, , , , , , , ,],
					[, 0, , , 3, , , , 3, 2, 0, , 3, 3, 3],
					[, 3, , , 3, , , 3, , , , , , ,],
					[, , , , , , , 2, , , , , , ,],
					[, , 2, 1, , , , 3, , , 3, , 0, 3],
					[3, , , , , 2, , , , , , , , , 2],
					[3, , 2, 1, , 0, , 3, , , 3, , 2, , 1],
					[3, , , , , 2, , 3, , , 3, , , ,],
					[, , 3, 3, , , , 3, , , , 2, 3, , 3],
				];

				// Canvas resizing
				const [rows, columns] = [puzzle[0].length, puzzle.length];
				const maxHorizontalSquares = Math.floor(window.innerWidth / columns);
				const maxVerticalSquares = Math.floor(window.innerHeight / rows);
				const squareWidth = Math.min(maxHorizontalSquares, maxVerticalSquares);
				const dotRadius = squareWidth / 8;
				const ctx = document.querySelector("canvas").getContext("2d");
				[ctx.canvas.width, ctx.canvas.height] = [
					columns * squareWidth + 2 * dotRadius,
					rows * squareWidth + 2 * dotRadius,
				];

				// Canvas text
				ctx.font = String(0.75 * squareWidth) + "px Arial";
				const textHeight = ctx.measureText("0123").actualBoundingBoxAscent; // actual height of text, unlike font size
				ctx.textAlign = "center";
				ctx.fillStyle = "white";

				// Initialisation //

				// Draw grid and numbers
				for (let i = 0; i < columns + 1; i++) {
					for (let j = 0; j < rows + 1; j++) {
						const [x, y] = transformToCanvas(i, j);
						drawDot(x, y);
						if (i < columns && j < rows) {
							const [valueX, valueY] = transformToCanvas(i, j);
							const value = puzzle[i][j];
							if (value != undefined) {
								ctx.fillText(
									String(value),
									valueX + squareWidth / 2,
									valueY + (textHeight + squareWidth) / 2
								);
							}
						}
					}
				}

				// Animation //

				// (function appLoop() {
				// 	window.requestAnimationFrame(appLoop);
				// 	update();
				// })();

				// Function Declarations //

				/* Chronological order of first execution:

				Initialisation
				1) transformToCanvas()
				2) drawDot()


				Animation
				)
				*/

				//function update() {}
				function transformToCanvas(x, y) {
					return [x * squareWidth + dotRadius, y * squareWidth + dotRadius];
				}
				function drawDot(x, y) {
					ctx.beginPath();
					ctx.arc(x, y, dotRadius, 0, Math.PI * 2, false);
					ctx.fill();
				}
			})();
		</script>
	</body>
</html>
